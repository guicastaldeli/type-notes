//FOR MESSAGE DISAPPEAR AFTER RELOAD (RIGHT)
const hasViewed = await initDB(db => getSettings(db, 'has-viewed'));
const localStorageViewed = localStorage.getItem('has-viewed') === 'true';
setShowMessage(hasViewed !== 'true' && !localStorageViewed);

//FOR CONTINUE
const hasViewed = await initDB(db => getSettings(db, 'has-viewed'));
setShowMessage(hasViewed == null);

{note.updatedAt !== note.createdAt && (
    <span id="___created-info">Updated: {formatDate(note.updatedAt)}</span>
)}

const addNote = async () => {
        if(!newNote.title.trim() || !newNote.content.trim()) return;
        
        try {
            const updId = await _addNote(newNote.title, newNote.content, currentSession);
            setNotes(prev => 
                [...prev, {
                    id: updId,
                    title: newNote.title,
                    content: newNote.content,
                    status: currentSession,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }
            ]);

            setNewNote({ title: '', content: '' });
            onComplete();
        } catch(e) {
            console.error(e);
        }
    }

    onInput={() => {
                                    if(!contentRef.current) return;
                                    const newContent = contentRef.current.innerHTML;
                                    
                                    if(isEditing) {
                                        setEditNote({ ...editNote, content: newContent });
                                    } else {
                                        setNewNote({ ...newNote, content: newContent })} 
                                    }
                                }

                                useEffect(() => {
        const handleClickOutside = (e: MouseEvent) => {
            if(contentRef.current && !contentRef.current.contains(e.target as Node)) {
                setShowFormatPicker(false);
                setShowColorPicker(false);
            }
        }

        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    });

    if(e) {
                            const activeNoteItems = document.querySelectorAll('#_note-item');
                            activeNoteItems.forEach(item => {
                                const id = Number(item.getAttribute('data-note-id'));
                                
                                if (!isNaN(id)) {
                                    console.log(item)
                                    if (selectedNotes.includes(id)) {
                                        item.classList.add('current');
                                    } else {
                                        item.classList.remove('current');
                                    }
                                } else {
                                    console.log('tst2')
                                }
                            });
                        }